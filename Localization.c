#pragma config(Sensor, S1,     Sonar,          sensorSONAR)
#pragma config(Sensor, S2,     Light,          sensorLightActive)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TURN 6
#define OFFSET 2
#define SPEED 12

#define MAP 679

#define OBJECT_THRESH 15

#define R 1.1
#define L 4.85
#define F 0.0

#define NUM_BINS 40
#define BIN_SIZE (60.0/(float)(NUM_BINS))

#define PI 3.1415926536

float robot_TH = 0.0, robot_X = 0.0, robot_Y = 0.0;
int oldL = 0, oldR = 0, oldT;
int velocityUpdateInterval = 10;
int PIDUpdateInterval = 2;

float totalDist = 0.0;

float bins[NUM_BINS];

float white, black, grey;

void initBins(){
	for(int i = 0; i < NUM_BINS; i++){
		bins[i] = 1.0/NUM_BINS;
	}
}

void shiftBins(){
	float oldD = totalDist;
	totalDist = abs(robot_X) + abs(robot_Y);
	if((int)(totalDist/BIN_SIZE) > (int)(oldD/BIN_SIZE)){
		float newBins[40];
		newBins[0] = bins[NUM_BINS-1];
		for(int i = 1; i < NUM_BINS; i++){
			newBins[i] = bins[i-1];
		}
		for(int i = 0; i < NUM_BINS; i++){
			bins[i] = newBins[i];
		}
	}
}

task trajectory_task()
{
	float t = 0.0;
	oldL = nMotorEncoder[LeftMotor];
	oldR = nMotorEncoder[RightMotor];
	oldT = nPgmTime;
	while(1)
	{
		int curTime = nPgmTime;
		int leftEnc = nMotorEncoder[LeftMotor];
		int rightEnc = nMotorEncoder[RightMotor];
		float dt = (curTime - oldT) / 1000.0;
		t += dt;
		if(dt == 0.0){
			continue;
		}
		float vl = (leftEnc - oldL) / dt * PI / 180.0 * R;
		float vr = (rightEnc - oldR) / dt * PI / 180.0 * R;

		float v = (vr + vl) / 2.0;

		float w = (vr - vl) / L;

		float k00 = v*cos(robot_TH);
		float k01 = v*sin(robot_TH);
		float k02 = w;
		float k10 = v*cos(robot_TH + k02*.5*dt);
		float k11 = v*sin(robot_TH + k02*.5*dt);
		float k12 = w;
		float k20 = v*cos(robot_TH + k12*.5*dt);
		float k21 = v*sin(robot_TH + k12*.5*dt);
		float k22 = w;
		float k30 = v*cos(robot_TH + k22*dt);
		float k31 = v*sin(robot_TH + k22*dt);
		float k32 = w;

		float dx = dt/6.0 * (k00 + 2*(k10 + k20) + k30);
		float dy = dt/6.0 * (k01 + 2*(k11 + k21) + k31);
		robot_X += dx;
		robot_Y += dy;
		robot_TH += dt/6.0 * (k02 + 2*(k12 + k22) + k32);

		displayTextLine(0, "X: %f", robot_X);
		displayTextLine(1, "Y: %f", robot_Y);
		displayTextLine(2, "th: %f", robot_TH * 180.0 / PI);
		displayTextLine(3, "time: %f", t);

		shiftBins();
		wait1Msec(velocityUpdateInterval);
		oldL = leftEnc;
		oldR = rightEnc;
		oldT = curTime;
	}
}

void calibrate(){
	// get white first
	while(nNxtButtonPressed != 3){
		white = SensorValue[Light];
	}
	while(nNxtButtonPressed != -1){}
	// then black
	while(nNxtButtonPressed != 3){
		black = SensorValue[Light];
	}
	while(nNxtButtonPressed != -1){}
	grey = (white+black) / 2.0;
	while(nNxtButtonPressed != 3){}
	while(nNxtButtonPressed != -1){}
}

bool objectDetected(){
	displayTextLine(4, "sonar: %d", SensorValue[Sonar]);
	return SensorValue[Sonar] <= OBJECT_THRESH;
}

task lineFollowing(){
	while(true){
		int reading = SensorValue[Light];
		int lineError = reading - grey;
		if(lineError > .1*grey){
			motor[LeftMotor] = TURN + OFFSET;
			motor[RightMotor] = OFFSET - TURN;
		}
		else if(lineError < -.1*grey){
			motor[LeftMotor] = OFFSET - TURN;
			motor[RightMotor] = OFFSET + TURN;
		}
		else{
			motor[LeftMotor] = SPEED;
			motor[RightMotor] = SPEED;
		}
		if(objectDetected()){
			playTone(600, 1);
		}
		wait1Msec(20);
	}
}

task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	initBins();

  motor[motorB] = 0;
	motor[motorC] = 0;

	calibrate();
	startTask(trajectory_task);
	startTask(lineFollowing);
	while(nNxtButtonPressed != kButtonExit){}
}
