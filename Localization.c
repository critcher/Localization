#pragma config(Sensor, S1,     Sonar,          sensorSONAR)
#pragma config(Sensor, S2,     Light,          sensorLightActive)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Line following parameters
#define TURN 9
#define OFFSET 2
#define SPEED 12

// Map and goal specification
#define MAP 1
#define GOAL 'F'

// maximum distance in cm to an obstacle
#define OBJECT_THRESH 15

// dead reckoning parameters
#define R 1.1
#define L 5.0
#define F 0.0

// total number of probability bins and size in inches of each bin
#define NUM_BINS 40
#define BIN_SIZE (60.0/(float)(NUM_BINS))

#define PI 3.1415926536

float robot_TH = 0.0, robot_X = 0.0, robot_Y = 0.0;
int oldL = 0, oldR = 0, oldT;
int velocityUpdateInterval = 10;
int PIDUpdateInterval = 2;

int goalBin = -1;
float totalDist = 0.0;

float bins[NUM_BINS];

float white, black, grey;

// returns the goal bin to end in
int getGoal(){
	int index = GOAL - 'A';
	return 4 * index;
}

// initialize the bins to equal probabilities
void initBins(){
	for(int i = 0; i < NUM_BINS; i++){
		bins[i] = 1.0/NUM_BINS;
	}
}

// take sin a distance traveled in a timestep and shifts the probabilities
// throught the bins if needed
void shiftBins(float dist){
	// update the total distance traveled
	float oldD = totalDist;
	totalDist += dist;
	displayTextLine(5,"%d",(int)(totalDist/BIN_SIZE));
	// if the robot has moved forward another bin, shift them all over 1
	if((int)(totalDist/BIN_SIZE) > (int)(oldD/BIN_SIZE)){
		float newBins[40];
		newBins[0] = bins[NUM_BINS-1];
		for(int i = 1; i < NUM_BINS; i++){
			newBins[i] = bins[i-1];
		}
		for(int i = 0; i < NUM_BINS; i++){
			bins[i] = newBins[i];
		}
	}
}

// should be called if an object is detected. Increases the probability of all bins
// that are in front of an obstacle
void registerObstacle(){
	for(int i = 0; i < NUM_BINS; i++){
		if((MAP >> (10*i/NUM_BINS)) & 0x1){
			bins[i] += 1;
		}
	}
}

// returns whether an obstacle is next to the robot or not
bool objectDetected(){
	displayTextLine(4,"sonar: %d", SensorValue[Sonar]);
	return SensorValue[Sonar] <= OBJECT_THRESH;
}

// dead reckoning/obstacle detection task
task trajectory_task()
{
	float t = 0.0;
	oldL = nMotorEncoder[LeftMotor];
	oldR = nMotorEncoder[RightMotor];
	oldT = nPgmTime;
	// normal dead reckoning code
	while(1)
	{
		int curTime = nPgmTime;
		int leftEnc = nMotorEncoder[LeftMotor];
		int rightEnc = nMotorEncoder[RightMotor];
		float dt = (curTime - oldT) / 1000.0;
		t += dt;
		if(dt == 0.0){
			continue;
		}
		float vl = (leftEnc - oldL) / dt * PI / 180.0 * R;
		float vr = (rightEnc - oldR) / dt * PI / 180.0 * R;

		float v = (vr + vl) / 2.0;

		float w = (vr - vl) / L;

		float k00 = v*cos(robot_TH);
		float k01 = v*sin(robot_TH);
		float k02 = w;
		float k10 = v*cos(robot_TH + k02*.5*dt);
		float k11 = v*sin(robot_TH + k02*.5*dt);
		float k12 = w;
		float k20 = v*cos(robot_TH + k12*.5*dt);
		float k21 = v*sin(robot_TH + k12*.5*dt);
		float k22 = w;
		float k30 = v*cos(robot_TH + k22*dt);
		float k31 = v*sin(robot_TH + k22*dt);
		float k32 = w;

		float dx = dt/6.0 * (k00 + 2*(k10 + k20) + k30);
		float dy = dt/6.0 * (k01 + 2*(k11 + k21) + k31);
		robot_X += dx;
		robot_Y += dy;
		robot_TH += dt/6.0 * (k02 + 2*(k12 + k22) + k32);

		displayTextLine(0, "X: %f", robot_X);
		displayTextLine(1, "Y: %f", robot_Y);
		displayTextLine(2, "th: %f", robot_TH * 180.0 / PI);
		displayTextLine(3, "time: %f", t);

		// shift the bins, check for an object, and register a hit, if needed
		float dist = sqrt(dx*dx + dy*dy);
		shiftBins(dist);
		if(objectDetected()){
			playTone(600, 1);
			registerObstacle();
			//normalizeBins();
		}
		wait1Msec(velocityUpdateInterval);
		oldL = leftEnc;
		oldR = rightEnc;
		oldT = curTime;
	}
}

// calibrates the line following
void calibrate(){
	// get white first
	while(nNxtButtonPressed != 3){
		white = SensorValue[Light];
	}
	while(nNxtButtonPressed != -1){}
	// then black
	while(nNxtButtonPressed != 3){
		black = SensorValue[Light];
	}
	while(nNxtButtonPressed != -1){}
	grey = (white+black) / 2.0;
	while(nNxtButtonPressed != 3){}
	while(nNxtButtonPressed != -1){}
}

// task for navigating around the black stripe
task lineFollowing(){
	while((int)(totalDist/BIN_SIZE) != goalBin){
		int reading = SensorValue[Light];
		int lineError = reading - grey;
		// if seeing white, turn right
		if(lineError > .1*grey){
			motor[LeftMotor] = TURN + OFFSET;
			motor[RightMotor] = OFFSET - TURN;
		}
		// if seeing black, turn left
		else if(lineError < -.1*grey){
			motor[LeftMotor] = OFFSET - TURN;
			motor[RightMotor] = OFFSET + TURN;
		}
		// otherwise, go straight
		else{
			motor[LeftMotor] = SPEED;
			motor[RightMotor] = SPEED;
		}
		wait1Msec(20);
		// if the robot has completed a loop, calculate the most probable
		// current location, and thus how many more bin lengths it should drive forward
		if((int)(totalDist/BIN_SIZE) == NUM_BINS && goalBin == -1){
			motor[LeftMotor] = 0;
			motor[RightMotor] = 0;
			float maxVal = 0.0;
			int maxInd = 0;
			for(int i = 0; i < NUM_BINS; i++){
				if(bins[i] > maxVal){
					maxVal = bins[i];
					maxInd = i;
				}
			}
			goalBin = getGoal();
			int binsLeft = (40 - maxInd + goalBin) % 40;
			goalBin = (int)(totalDist/BIN_SIZE) + binsLeft;
		}
	}
	// once the goal bin has been reached, stop and play a tone
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	playTone(1000, 200);
}

task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	initBins();

  motor[motorB] = 0;
	motor[motorC] = 0;

	calibrate();
	startTask(trajectory_task);
	startTask(lineFollowing);
	while(nNxtButtonPressed != kButtonExit){}
}
